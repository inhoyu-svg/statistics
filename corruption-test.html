<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Corruption Effect Test - 찢김 효과 테스트</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: 'SCDream', -apple-system, BlinkMacSystemFont, sans-serif;
      background: #1a1a2e;
      color: #e5e7eb;
      padding: 20px;
      min-height: 100vh;
    }
    h1 { text-align: center; margin-bottom: 20px; color: #93DA6A; }
    .container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
    }
    .test-section {
      background: #16213e;
      border-radius: 12px;
      padding: 20px;
      min-width: 400px;
    }
    .test-section h2 {
      margin-bottom: 15px;
      color: #61C1F9;
      font-size: 18px;
    }
    canvas {
      display: block;
      margin: 0 auto;
      background: #0f0f23;
      border-radius: 8px;
    }
    .controls {
      margin-top: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .control-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .control-row label {
      min-width: 120px;
      font-size: 14px;
    }
    .control-row input[type="range"] {
      flex: 1;
    }
    .control-row input[type="color"] {
      width: 40px;
      height: 30px;
      border: none;
      cursor: pointer;
    }
    .control-row span {
      min-width: 50px;
      text-align: right;
      font-size: 12px;
      color: #888;
    }
    button {
      background: #93DA6A;
      color: #1a1a2e;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      margin-top: 10px;
    }
    button:hover { background: #AEFF7E; }
    .info {
      font-size: 12px;
      color: #888;
      margin-top: 10px;
      padding: 10px;
      background: #0f0f23;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <h1>Corruption Effect Test</h1>

  <div class="container">
    <!-- 기본 찢김 경로 테스트 -->
    <div class="test-section">
      <h2>1. 찢김 경로 테스트</h2>
      <canvas id="tearPathCanvas" width="400" height="300"></canvas>
      <div class="controls">
        <div class="control-row">
          <label>Edge Complexity:</label>
          <input type="range" id="complexity" min="0" max="1" step="0.1" value="0.7">
          <span id="complexityValue">0.7</span>
        </div>
        <div class="control-row">
          <label>Seed:</label>
          <input type="range" id="seed" min="0" max="100" step="1" value="42">
          <span id="seedValue">42</span>
        </div>
        <div class="control-row">
          <label>투명 모드:</label>
          <input type="checkbox" id="pathTransparent">
        </div>
        <div class="control-row">
          <label>종이 섬유:</label>
          <input type="checkbox" id="pathFiber">
        </div>
        <div class="control-row">
          <label>가장자리 색상:</label>
          <input type="checkbox" id="pathEdgeColor">
        </div>
        <div class="control-row">
          <label>레이어 수:</label>
          <input type="range" id="pathLayers" min="1" max="3" step="1" value="1">
          <span id="pathLayersValue">1</span>
        </div>
        <button onclick="redrawTearPath()">다시 그리기</button>
      </div>
      <div class="info">
        <b>시각적 질감 옵션:</b><br>
        • 종이 섬유: 찢긴 가장자리에 미세한 선<br>
        • 가장자리 색상: 오래된 종이 느낌의 갈색 테두리<br>
        • 레이어 수: 깊이감 (1~3겹)
      </div>
    </div>

    <!-- 차트 마스킹 테스트 -->
    <div class="test-section">
      <h2>2. 차트 막대 마스킹</h2>
      <canvas id="chartCanvas" width="500" height="350"></canvas>
      <div class="controls">
        <div class="control-row">
          <label>마스킹할 셀:</label>
          <input type="text" id="chartMaskedCells" value="0-0:2-0, 0-2:0-4" style="flex:1; padding:5px;">
        </div>
        <div class="info" style="margin-top:0; margin-bottom:5px;">
          <b>좌표계:</b> x-y (0-0=좌하단) | <b>예:</b> <code>1-3</code> 단일셀, <code>3-2:4-4</code> 범위
        </div>
        <div class="control-row">
          <label>찢김 색상:</label>
          <input type="color" id="tearColor" value="#1a1a2e">
        </div>
        <div class="control-row">
          <label>그림자:</label>
          <input type="checkbox" id="shadowEnabled" checked>
        </div>
        <div class="control-row">
          <label>투명 모드:</label>
          <input type="checkbox" id="transparentMode" checked>
          <span style="color:#93DA6A;">← 찢긴 부분이 투명</span>
        </div>
        <div class="control-row">
          <label>축 라벨도 마스킹:</label>
          <input type="checkbox" id="maskAxisLabels" checked>
          <span style="font-size:11px; color:#888;">← 축에 닿는 범위일 때</span>
        </div>
        <button onclick="redrawChart()">다시 그리기</button>
      </div>
    </div>

    <!-- 테이블 마스킹 테스트 -->
    <div class="test-section">
      <h2>3. 테이블 셀 마스킹</h2>
      <canvas id="tableCanvas" width="450" height="300"></canvas>
      <div class="controls">
        <div class="control-row">
          <label>마스킹할 셀:</label>
          <input type="text" id="maskedCells" value="row:2, 3-1:3-2" style="flex:1; padding:5px;">
        </div>
        <div class="info" style="margin-top:5px; margin-bottom:10px;">
          형식: <code>row:N</code> 행전체, <code>col:N</code> 열전체, <code>R-C</code> 단일셀, <code>R1-C1:R2-C2</code> 범위
        </div>
        <div class="control-row">
          <label>투명 모드:</label>
          <input type="checkbox" id="tableTransparent" checked>
        </div>
        <button onclick="redrawTable()">다시 그리기</button>
      </div>
    </div>

    <!-- 애니메이션 테스트 -->
    <div class="test-section">
      <h2>4. 애니메이션 효과</h2>
      <canvas id="animCanvas" width="400" height="250"></canvas>
      <div class="controls">
        <div class="control-row">
          <label>애니메이션:</label>
          <select id="animType" style="flex:1; padding:5px;">
            <option value="none">없음 (즉시)</option>
            <option value="fadeIn">페이드 인</option>
            <option value="expand">확장</option>
            <option value="diagonalTear" selected>대각선 찢김 ↗</option>
          </select>
        </div>
        <div class="control-row">
          <label>지속시간:</label>
          <input type="range" id="animDuration" min="300" max="2000" step="100" value="800">
          <span id="animDurationValue">800ms</span>
        </div>
        <div class="control-row">
          <label>종이 섬유:</label>
          <input type="checkbox" id="animFiber" checked>
        </div>
        <div class="control-row">
          <label>가장자리 색상:</label>
          <input type="checkbox" id="animEdgeColor" checked>
        </div>
        <div class="control-row">
          <label>레이어 수:</label>
          <input type="range" id="animLayers" min="1" max="3" step="1" value="2">
          <span id="animLayersValue">2</span>
        </div>
        <button onclick="playAnimation()">▶ 재생</button>
      </div>
    </div>

    <!-- 영역 마스킹 테스트 -->
    <div class="test-section">
      <h2>5. 영역 마스킹 (차트)</h2>
      <canvas id="regionCanvas" width="500" height="350"></canvas>
      <div class="controls">
        <div class="control-row">
          <label>X 범위 (막대):</label>
          <input type="text" id="regionX" value="1-3" style="flex:1; padding:5px;">
        </div>
        <div class="control-row">
          <label>Y 범위 (값):</label>
          <input type="text" id="regionY" value="0.1-0.3" style="flex:1; padding:5px;">
        </div>
        <div class="control-row">
          <label>투명 모드:</label>
          <input type="checkbox" id="regionTransparent" checked>
        </div>
        <button onclick="redrawRegion()">다시 그리기</button>
      </div>
    </div>
  </div>

  <script>
    // ==========================================
    // Noise 유틸리티 함수
    // ==========================================

    /**
     * 간단한 Pseudo-Random Noise
     * @param {number} x - 입력값
     * @param {number} seed - 시드값
     * @returns {number} -1 ~ 1 범위의 노이즈
     */
    function simpleNoise(x, seed = 0) {
      const n = Math.sin(x * 12.9898 + seed * 78.233) * 43758.5453;
      return (n - Math.floor(n)) * 2 - 1;
    }

    /**
     * Smoothstep 보간이 적용된 부드러운 Noise
     */
    function smoothNoise(x, seed = 0) {
      const x0 = Math.floor(x);
      const x1 = x0 + 1;
      const t = x - x0;

      const n0 = simpleNoise(x0, seed);
      const n1 = simpleNoise(x1, seed);

      // Smoothstep 보간
      const st = t * t * (3 - 2 * t);
      return n0 + (n1 - n0) * st;
    }

    /**
     * 찢김 경로 생성
     * @param {number} startX - 시작 X
     * @param {number} startY - 시작 Y
     * @param {number} endX - 끝 X
     * @param {number} endY - 끝 Y
     * @param {number} complexity - 불규칙성 (0~1)
     * @param {number} seed - 랜덤 시드
     * @returns {Array} 경로 점 배열
     */
    function generateTearPath(startX, startY, endX, endY, complexity = 0.7, seed = 42) {
      const points = [];
      const dx = endX - startX;
      const dy = endY - startY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const segments = Math.max(15, Math.floor(distance / 4));

      // 수직선인지 수평선인지 판단
      const isVertical = Math.abs(dx) < Math.abs(dy);
      const amplitude = complexity * 12; // 최대 12px 변위

      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const baseX = startX + dx * t;
        const baseY = startY + dy * t;

        // 여러 주파수의 노이즈 합성 (Fractal Noise)
        let noise = 0;
        noise += smoothNoise(t * 8, seed) * 1.0;
        noise += smoothNoise(t * 16, seed + 1) * 0.5;
        noise += smoothNoise(t * 32, seed + 2) * 0.25;
        noise = noise / 1.75; // 정규화

        const offset = noise * amplitude;

        if (isVertical) {
          points.push({ x: baseX + offset, y: baseY });
        } else {
          points.push({ x: baseX, y: baseY + offset });
        }
      }

      return points;
    }

    /**
     * 종이 섬유 효과 렌더링
     */
    function renderFibers(ctx, allEdges, options = {}) {
      const {
        fiberCount = 20,
        fiberLength = 10,
        color = 'rgba(180, 150, 100, 0.5)'
      } = options;

      // 모든 가장자리 점 합치기
      const allPoints = [...allEdges.top, ...allEdges.right, ...allEdges.bottom, ...allEdges.left];

      ctx.save();
      // 랜덤 시드 고정을 위한 간단한 방법
      let randIndex = 0;
      const pseudoRandom = () => {
        randIndex++;
        return (Math.sin(randIndex * 12.9898) * 43758.5453) % 1;
      };

      allPoints.forEach((point, i) => {
        if (pseudoRandom() > 0.25) return; // 25%만 섬유 그리기

        const angle = (pseudoRandom() - 0.5) * Math.PI; // -90도 ~ 90도
        const length = fiberLength * (0.4 + pseudoRandom() * 0.6);

        ctx.beginPath();
        ctx.moveTo(point.x, point.y);
        ctx.lineTo(
          point.x + Math.cos(angle) * length,
          point.y + Math.sin(angle) * length
        );
        ctx.strokeStyle = color;
        ctx.lineWidth = 0.3 + pseudoRandom() * 0.7;
        ctx.stroke();
      });
      ctx.restore();
    }

    /**
     * 가장자리 색상 테두리 렌더링 (오래된 종이 느낌)
     */
    function renderEdgeColor(ctx, allEdges, options = {}) {
      const { color = 'rgba(160, 130, 80, 0.4)', width = 3 } = options;

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // 각 변을 따라 테두리 그리기
      ['top', 'right', 'bottom', 'left'].forEach(edge => {
        const points = allEdges[edge];
        if (points.length < 2) return;

        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        points.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.stroke();
      });
      ctx.restore();
    }

    /**
     * 찢김 마스크 렌더링
     * @param {CanvasRenderingContext2D} ctx
     * @param {Object} region - 영역 {x, y, width, height}
     * @param {Object} style - 스타일 설정
     */
    function renderTearMask(ctx, region, style = {}) {
      const { x, y, width, height } = region;
      const {
        edgeComplexity = 0.7,
        tearColor = '#1a1a2e',
        shadowEnabled = true,
        transparent = false,
        seed = Math.random() * 100,
        // 시각적 질감 옵션
        fiberEnabled = false,
        fiberCount = 20,
        fiberColor = 'rgba(180, 150, 100, 0.5)',
        layerCount = 1,
        edgeColorEnabled = false,
        edgeColor = 'rgba(160, 130, 80, 0.4)'
      } = style;

      ctx.save();

      // 다중 레이어 렌더링
      for (let layer = layerCount - 1; layer >= 0; layer--) {
        const layerOffset = layer * 2;
        const layerOpacity = 1 - (layer * 0.25);
        const layerSeed = seed + layer * 50;

        const layerRegion = {
          x: x - layerOffset,
          y: y - layerOffset,
          width: width + layerOffset * 2,
          height: height + layerOffset * 2
        };

        // 4변의 찢김 경로 생성
        const topEdge = generateTearPath(layerRegion.x, layerRegion.y, layerRegion.x + layerRegion.width, layerRegion.y, edgeComplexity, layerSeed);
        const rightEdge = generateTearPath(layerRegion.x + layerRegion.width, layerRegion.y, layerRegion.x + layerRegion.width, layerRegion.y + layerRegion.height, edgeComplexity, layerSeed + 10);
        const bottomEdge = generateTearPath(layerRegion.x + layerRegion.width, layerRegion.y + layerRegion.height, layerRegion.x, layerRegion.y + layerRegion.height, edgeComplexity, layerSeed + 20);
        const leftEdge = generateTearPath(layerRegion.x, layerRegion.y + layerRegion.height, layerRegion.x, layerRegion.y, edgeComplexity, layerSeed + 30);

        const allEdges = { top: topEdge, right: rightEdge, bottom: bottomEdge, left: leftEdge };

        // 경로 생성 함수
        function createTearPath() {
          ctx.beginPath();
          ctx.moveTo(topEdge[0].x, topEdge[0].y);
          topEdge.forEach(p => ctx.lineTo(p.x, p.y));
          rightEdge.forEach(p => ctx.lineTo(p.x, p.y));
          bottomEdge.forEach(p => ctx.lineTo(p.x, p.y));
          leftEdge.forEach(p => ctx.lineTo(p.x, p.y));
          ctx.closePath();
        }

        // 첫 번째 레이어만 실제 마스킹
        if (layer === 0) {
          if (transparent) {
            // destination-out으로 영역 지우기 (투명하게)
            ctx.globalCompositeOperation = 'destination-out';
            createTearPath();
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';

            // 가장자리 색상 (오래된 종이)
            if (edgeColorEnabled) {
              renderEdgeColor(ctx, allEdges, { color: edgeColor, width: 2 });
            }

            // 종이 섬유 효과
            if (fiberEnabled) {
              renderFibers(ctx, allEdges, { fiberCount, color: fiberColor });
            }
          } else {
            // 기존 모드: 단색으로 덮기
            if (shadowEnabled) {
              ctx.shadowColor = 'rgba(0, 0, 0, 0.6)';
              ctx.shadowBlur = 15;
              ctx.shadowOffsetX = 4;
              ctx.shadowOffsetY = 4;
            }

            createTearPath();
            ctx.fillStyle = tearColor;
            ctx.fill();

            ctx.shadowColor = 'transparent';
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // 가장자리 색상 (오래된 종이)
            if (edgeColorEnabled) {
              renderEdgeColor(ctx, allEdges, { color: edgeColor, width: 2 });
            }

            // 종이 섬유 효과
            if (fiberEnabled) {
              renderFibers(ctx, allEdges, { fiberCount, color: fiberColor });
            }
          }
        } else {
          // 뒷 레이어: 그림자 효과만 (깊이감)
          ctx.globalAlpha = 0.15 * (layerCount - layer);
          createTearPath();
          ctx.strokeStyle = 'rgba(100, 80, 50, 0.5)';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.globalAlpha = 1;
        }
      }

      ctx.restore();
    }

    // ==========================================
    // 테스트 1: 찢김 경로 테스트
    // ==========================================

    function redrawTearPath() {
      const canvas = document.getElementById('tearPathCanvas');
      const ctx = canvas.getContext('2d');
      const complexity = parseFloat(document.getElementById('complexity').value);
      const seed = parseInt(document.getElementById('seed').value);
      const transparentMode = document.getElementById('pathTransparent').checked;
      const fiberEnabled = document.getElementById('pathFiber').checked;
      const edgeColorEnabled = document.getElementById('pathEdgeColor').checked;
      const layerCount = parseInt(document.getElementById('pathLayers').value);

      document.getElementById('complexityValue').textContent = complexity.toFixed(1);
      document.getElementById('seedValue').textContent = seed;
      document.getElementById('pathLayersValue').textContent = layerCount;

      // 배경 클리어
      ctx.fillStyle = '#0f0f23';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 참조용 격자
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      for (let i = 0; i < canvas.width; i += 50) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, canvas.height);
        ctx.stroke();
      }
      for (let i = 0; i < canvas.height; i += 50) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(canvas.width, i);
        ctx.stroke();
      }

      // 투명 모드 테스트용: 중앙에 색상 사각형 추가
      if (transparentMode) {
        ctx.fillStyle = '#93DA6A';
        ctx.fillRect(100, 80, 200, 140);
        ctx.fillStyle = '#61C1F9';
        ctx.font = 'bold 20px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('이 텍스트가 보여야 함', 200, 150);
      }

      // 찢김 마스크 렌더링
      renderTearMask(ctx, {
        x: 80,
        y: 60,
        width: 240,
        height: 180
      }, {
        edgeComplexity: complexity,
        tearColor: '#1a1a2e',
        shadowEnabled: false,
        transparent: transparentMode,
        seed: seed,
        // 시각적 질감 옵션
        fiberEnabled: fiberEnabled,
        fiberCount: 25,
        edgeColorEnabled: edgeColorEnabled,
        layerCount: layerCount
      });
    }

    // ==========================================
    // 테스트 2: 차트 막대 마스킹
    // ==========================================

    /**
     * 차트 셀 범위 파싱 (x-y 형식)
     * 형식: "0-2, 1-2:2-4, 3-0:3-4"
     * - "0-2" → 단일 셀 (x=0, y=2)
     * - "1-2:2-4" → 범위 (x=1~2, y=2~4)
     * 반환: [{x1, y1, x2, y2}, ...]
     */
    function parseChartCells(input) {
      const ranges = [];
      const parts = input.split(',').map(s => s.trim()).filter(s => s);

      parts.forEach(part => {
        if (part.includes(':')) {
          // 범위: "1-2:2-4"
          const [start, end] = part.split(':').map(s => s.trim());
          const [x1, y1] = start.split('-').map(n => parseInt(n.trim()));
          const [x2, y2] = end.split('-').map(n => parseInt(n.trim()));
          if (!isNaN(x1) && !isNaN(y1) && !isNaN(x2) && !isNaN(y2)) {
            ranges.push({
              x1: Math.min(x1, x2),
              y1: Math.min(y1, y2),
              x2: Math.max(x1, x2),
              y2: Math.max(y1, y2)
            });
          }
        } else if (part.includes('-')) {
          // 단일 셀: "0-2"
          const [x, y] = part.split('-').map(n => parseInt(n.trim()));
          if (!isNaN(x) && !isNaN(y)) {
            ranges.push({ x1: x, y1: y, x2: x, y2: y });
          }
        }
      });

      return ranges;
    }

    /**
     * 셀 좌표 → 픽셀 좌표 변환
     * @param {number} cellX - X축 셀 인덱스 (막대 인덱스)
     * @param {number} cellY - Y축 셀 인덱스 (0=하단, gridDivisions-1=상단)
     * @param {Object} chartInfo - 차트 정보 {padding, barWidth, gap, chartHeight, gridDivisions, maxY}
     * @returns {{x, y, width, height}} 픽셀 좌표 및 크기
     */
    function cellToPixel(cellX, cellY, chartInfo) {
      const { padding, barWidth, gap, chartHeight, gridDivisions, canvasHeight } = chartInfo;

      // X: 막대 시작 위치
      const pixelX = padding + (barWidth + gap) * cellX + gap / 2;

      // 셀 높이
      const cellHeight = chartHeight / gridDivisions;

      // Y: 아래에서부터 계산 (cellY=0이 하단)
      const pixelY = canvasHeight - padding - cellHeight * (cellY + 1);

      return {
        x: pixelX,
        y: pixelY,
        width: barWidth,
        height: cellHeight
      };
    }

    /**
     * 셀 범위 → 픽셀 영역 변환
     */
    function cellRangeToPixel(range, chartInfo) {
      const topLeft = cellToPixel(range.x1, range.y2, chartInfo);
      const bottomRight = cellToPixel(range.x2, range.y1, chartInfo);

      return {
        x: topLeft.x,
        y: topLeft.y,
        width: bottomRight.x + bottomRight.width - topLeft.x,
        height: bottomRight.y + bottomRight.height - topLeft.y
      };
    }

    function redrawChart() {
      const canvas = document.getElementById('chartCanvas');
      const ctx = canvas.getContext('2d');
      const maskedCellsInput = document.getElementById('chartMaskedCells').value;
      const tearColor = document.getElementById('tearColor').value;
      const shadowEnabled = document.getElementById('shadowEnabled').checked;
      const transparentMode = document.getElementById('transparentMode').checked;
      const maskAxisLabels = document.getElementById('maskAxisLabels').checked;

      const cellRanges = parseChartCells(maskedCellsInput);

      // 배경 클리어
      ctx.fillStyle = '#0f0f23';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 샘플 데이터
      const data = [0.12, 0.24, 0.28, 0.20, 0.16];
      const padding = 60;
      const chartWidth = canvas.width - padding * 2;
      const chartHeight = canvas.height - padding * 2;
      const barWidth = chartWidth / data.length * 0.8;
      const gap = chartWidth / data.length * 0.2;
      const gridDivisions = 5;
      const maxY = 0.3;

      // 차트 정보 (셀 좌표 변환용)
      const chartInfo = {
        padding,
        barWidth,
        gap,
        chartHeight,
        gridDivisions,
        canvasHeight: canvas.height,
        maxY,
        dataLength: data.length
      };

      // 축 그리기
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, canvas.height - padding);
      ctx.lineTo(canvas.width - padding, canvas.height - padding);
      ctx.stroke();

      // Y축 라벨 및 격자선
      ctx.fillStyle = '#e5e7eb';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'right';
      for (let i = 0; i <= gridDivisions; i++) {
        const y = canvas.height - padding - (chartHeight * i / gridDivisions);
        const value = (maxY * i / gridDivisions).toFixed(2);
        ctx.fillText(value, padding - 10, y + 4);

        // 격자선 (수평)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(canvas.width - padding, y);
        ctx.stroke();
      }

      // 세로 격자선 (막대 경계)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
      for (let i = 0; i <= data.length; i++) {
        const x = padding + (barWidth + gap) * i + gap / 2;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, canvas.height - padding);
        ctx.stroke();
      }

      // 막대 그리기
      data.forEach((value, index) => {
        const x = padding + (barWidth + gap) * index + gap / 2;
        const barHeight = (value / maxY) * chartHeight;
        const y = canvas.height - padding - barHeight;

        // 그라데이션
        const gradient = ctx.createLinearGradient(x, y, x, canvas.height - padding);
        gradient.addColorStop(0, '#AEFF7E');
        gradient.addColorStop(1, '#68994C');

        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, barWidth, barHeight);

        // 테두리
        ctx.strokeStyle = '#68994C';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, barWidth, barHeight);

        // X축 라벨
        ctx.fillStyle = '#e5e7eb';
        ctx.textAlign = 'center';
        ctx.fillText(`${60 + index * 10}~${70 + index * 10}`, x + barWidth / 2, canvas.height - padding + 20);
      });

      // 그리드 셀 기반 마스킹
      cellRanges.forEach((range, rangeIndex) => {
        // 유효 범위 검증
        if (range.x1 < 0 || range.x2 >= data.length) return;
        if (range.y1 < 0 || range.y2 >= gridDivisions) return;

        // 셀 범위 → 픽셀 영역 변환
        const region = cellRangeToPixel(range, chartInfo);

        // 여백 추가
        const maskPadding = 4;

        // 마스킹 영역 계산 (기본: 셀 영역)
        let maskX = region.x - maskPadding;
        let maskY = region.y - maskPadding;
        let maskWidth = region.width + maskPadding * 2;
        let maskHeight = region.height + maskPadding * 2;

        // 축 라벨까지 확장 (옵션이 켜져 있고, 축에 닿는 범위일 때)
        if (maskAxisLabels) {
          // X축 라벨까지 확장: y=0 고정 (y1=0, y2=0)
          const touchesXAxis = (range.y1 === 0 && range.y2 === 0);
          // Y축 라벨까지 확장: x=0 고정 (x1=0, x2=0)
          const touchesYAxis = (range.x1 === 0 && range.x2 === 0);

          if (touchesXAxis) {
            // 아래로 확장 (X축 라벨 영역까지)
            const extendDown = 30; // X축 라벨 높이
            maskHeight += extendDown;
          }

          if (touchesYAxis) {
            // 왼쪽으로 확장 (Y축 라벨 영역까지)
            const extendLeft = maskX - 5; // 캔버스 왼쪽 여백까지
            maskWidth += extendLeft;
            maskX = 5;
          }
        }

        // 하나의 영역으로 마스킹
        renderTearMask(ctx, {
          x: maskX,
          y: maskY,
          width: maskWidth,
          height: maskHeight
        }, {
          edgeComplexity: 0.7,
          tearColor: tearColor,
          shadowEnabled: shadowEnabled,
          transparent: transparentMode,
          seed: rangeIndex * 100 + range.x1 * 10 + range.y1
        });
      });
    }

    // ==========================================
    // 테스트 3: 테이블 셀 마스킹
    // ==========================================

    /**
     * 테이블 셀 범위 파싱
     * 형식: "row:2, col:1, 3-1, 2-1:2-3"
     * 반환: [{rowStart, rowEnd, colStart, colEnd}, ...]
     */
    function parseCellRanges(input, totalRows, totalCols) {
      const ranges = [];
      const parts = input.split(',').map(s => s.trim()).filter(s => s);

      parts.forEach(part => {
        // row:N - 행 전체
        if (part.startsWith('row:')) {
          const row = parseInt(part.substring(4));
          if (!isNaN(row)) {
            ranges.push({ rowStart: row, rowEnd: row, colStart: 0, colEnd: totalCols - 1 });
          }
        }
        // col:N - 열 전체
        else if (part.startsWith('col:')) {
          const col = parseInt(part.substring(4));
          if (!isNaN(col)) {
            ranges.push({ rowStart: 0, rowEnd: totalRows - 1, colStart: col, colEnd: col });
          }
        }
        // R1-C1:R2-C2 - 범위
        else if (part.includes(':')) {
          const [start, end] = part.split(':');
          const [r1, c1] = start.split('-').map(n => parseInt(n));
          const [r2, c2] = end.split('-').map(n => parseInt(n));
          if (!isNaN(r1) && !isNaN(c1) && !isNaN(r2) && !isNaN(c2)) {
            ranges.push({
              rowStart: Math.min(r1, r2),
              rowEnd: Math.max(r1, r2),
              colStart: Math.min(c1, c2),
              colEnd: Math.max(c1, c2)
            });
          }
        }
        // R-C - 단일 셀
        else if (part.includes('-')) {
          const [row, col] = part.split('-').map(n => parseInt(n));
          if (!isNaN(row) && !isNaN(col)) {
            ranges.push({ rowStart: row, rowEnd: row, colStart: col, colEnd: col });
          }
        }
      });

      return ranges;
    }

    function redrawTable() {
      const canvas = document.getElementById('tableCanvas');
      const ctx = canvas.getContext('2d');
      const maskedCellsInput = document.getElementById('maskedCells').value;
      const transparentMode = document.getElementById('tableTransparent').checked;

      // 배경 클리어
      ctx.fillStyle = '#0f0f23';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 테이블 구조
      const tableData = [
        ['계급', '도수', '상대도수(%)'],
        ['60~70', '3', '12'],
        ['70~80', '6', '24'],
        ['80~90', '7', '28'],
        ['90~100', '4', '16'],
        ['합계', '20', '100']
      ];

      const cellWidth = 130;
      const cellHeight = 40;
      const startX = 30;
      const startY = 20;

      // 테이블 그리기
      tableData.forEach((row, rowIndex) => {
        row.forEach((cell, colIndex) => {
          const x = startX + colIndex * cellWidth;
          const y = startY + rowIndex * cellHeight;

          // 배경
          if (rowIndex === 0) {
            ctx.fillStyle = '#2a4a3a'; // 헤더
          } else if (rowIndex === tableData.length - 1) {
            ctx.fillStyle = '#3a3a5a'; // 합계
          } else if (rowIndex % 2 === 0) {
            ctx.fillStyle = '#1a1a2e';
          } else {
            ctx.fillStyle = '#16213e';
          }
          ctx.fillRect(x, y, cellWidth, cellHeight);

          // 테두리
          ctx.strokeStyle = '#444';
          ctx.lineWidth = 1;
          ctx.strokeRect(x, y, cellWidth, cellHeight);

          // 텍스트
          ctx.fillStyle = '#e5e7eb';
          ctx.font = rowIndex === 0 ? 'bold 14px sans-serif' : '14px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(cell, x + cellWidth / 2, y + cellHeight / 2);
        });
      });

      // 셀 범위 파싱
      const cellRanges = parseCellRanges(maskedCellsInput, tableData.length, tableData[0].length);

      // 마스킹할 셀 범위에 찢김 효과 적용
      cellRanges.forEach((range, rangeIndex) => {
        const { rowStart, rowEnd, colStart, colEnd } = range;

        // 범위 유효성 검사
        const r1 = Math.max(0, rowStart);
        const r2 = Math.min(tableData.length - 1, rowEnd);
        const c1 = Math.max(0, colStart);
        const c2 = Math.min(tableData[0].length - 1, colEnd);

        if (r1 > r2 || c1 > c2) return;

        // 범위 전체를 덮는 영역 계산
        const x = startX + c1 * cellWidth;
        const y = startY + r1 * cellHeight;
        const width = (c2 - c1 + 1) * cellWidth;
        const height = (r2 - r1 + 1) * cellHeight;

        // 셀 내부만 마스킹 (테두리는 보존)
        const inset = 3;
        renderTearMask(ctx, {
          x: x + inset,
          y: y + inset,
          width: width - inset * 2,
          height: height - inset * 2
        }, {
          edgeComplexity: 0.5,
          tearColor: '#1a1a2e',
          shadowEnabled: true,
          transparent: transparentMode,
          seed: rangeIndex * 100 + r1 * 10 + c1
        });
      });
    }

    // ==========================================
    // 테스트 4: 애니메이션 효과
    // ==========================================

    let animationId = null;

    function drawAnimBase(ctx, canvas) {
      // 배경
      ctx.fillStyle = '#0f0f23';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 샘플 막대 차트
      const data = [0.15, 0.28, 0.22, 0.18];
      const padding = 50;
      const barWidth = 60;
      const gap = 20;
      const chartHeight = canvas.height - padding * 2;

      data.forEach((value, i) => {
        const x = padding + (barWidth + gap) * i;
        const barHeight = value / 0.3 * chartHeight;
        const y = canvas.height - padding - barHeight;

        const gradient = ctx.createLinearGradient(x, y, x, canvas.height - padding);
        gradient.addColorStop(0, '#AEFF7E');
        gradient.addColorStop(1, '#68994C');

        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, barWidth, barHeight);
      });

      // 축
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, canvas.height - padding);
      ctx.lineTo(canvas.width - padding, canvas.height - padding);
      ctx.stroke();
    }

    function playAnimation() {
      const canvas = document.getElementById('animCanvas');
      const ctx = canvas.getContext('2d');
      const animType = document.getElementById('animType').value;
      const duration = parseInt(document.getElementById('animDuration').value);
      const fiberEnabled = document.getElementById('animFiber').checked;
      const edgeColorEnabled = document.getElementById('animEdgeColor').checked;
      const layerCount = parseInt(document.getElementById('animLayers').value);

      document.getElementById('animDurationValue').textContent = duration + 'ms';
      document.getElementById('animLayersValue').textContent = layerCount;

      // 기존 애니메이션 취소
      if (animationId) cancelAnimationFrame(animationId);

      const startTime = performance.now();
      const tearRegion = { x: 100, y: 40, width: 120, height: 130 };
      const seed = 42;

      // 시각적 질감 옵션
      const textureOptions = {
        fiberEnabled,
        fiberCount: 25,
        edgeColorEnabled,
        layerCount
      };

      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // 이징 함수 (ease-out)
        const eased = 1 - Math.pow(1 - progress, 3);

        // 베이스 그리기
        drawAnimBase(ctx, canvas);

        if (animType === 'none') {
          // 즉시 표시
          renderTearMask(ctx, tearRegion, {
            edgeComplexity: 0.7,
            transparent: true,
            shadowEnabled: false,
            seed: seed,
            ...textureOptions
          });
        } else if (animType === 'fadeIn') {
          // 페이드 인: globalAlpha 조절
          ctx.save();
          ctx.globalAlpha = eased;
          renderTearMask(ctx, tearRegion, {
            edgeComplexity: 0.7,
            transparent: true,
            shadowEnabled: false,
            seed: seed,
            ...textureOptions
          });
          ctx.restore();
        } else if (animType === 'expand') {
          // 확장: 중심에서 바깥으로
          const cx = tearRegion.x + tearRegion.width / 2;
          const cy = tearRegion.y + tearRegion.height / 2;
          const currentWidth = tearRegion.width * eased;
          const currentHeight = tearRegion.height * eased;

          renderTearMask(ctx, {
            x: cx - currentWidth / 2,
            y: cy - currentHeight / 2,
            width: currentWidth,
            height: currentHeight
          }, {
            edgeComplexity: 0.7,
            transparent: true,
            shadowEnabled: false,
            seed: seed,
            ...textureOptions
          });
        } else if (animType === 'diagonalTear') {
          // 대각선 찢김: 좌하단 → 우상단
          // progress에 따라 대각선으로 찢어지는 영역 계산
          const { x, y, width, height } = tearRegion;

          // 대각선 진행 좌표
          const diagX = x + width * eased * 2; // 하단에서 진행
          const diagY = y + height * (1 - eased * 2); // 우측에서 진행

          // 찢김 영역을 대각선으로 클리핑
          ctx.save();

          // 대각선 클리핑 경로 (좌하단에서 시작해서 우상단으로)
          ctx.beginPath();
          if (eased < 0.5) {
            // 전반부: 삼각형이 커짐
            const prog = eased * 2;
            ctx.moveTo(x, y + height); // 좌하단
            ctx.lineTo(x + width * prog, y + height); // 하단 진행
            ctx.lineTo(x, y + height * (1 - prog)); // 좌측 진행
          } else {
            // 후반부: 사다리꼴 → 전체
            const prog = (eased - 0.5) * 2;
            ctx.moveTo(x, y + height); // 좌하단
            ctx.lineTo(x + width, y + height); // 우하단
            ctx.lineTo(x + width, y + height * (1 - prog)); // 우측 진행
            ctx.lineTo(x + width * (1 - prog), y); // 상단 진행
            ctx.lineTo(x, y); // 좌상단
          }
          ctx.closePath();
          ctx.clip();

          // 클리핑 영역 내에서 전체 찢김 마스크 렌더링
          renderTearMask(ctx, tearRegion, {
            edgeComplexity: 0.7,
            transparent: true,
            shadowEnabled: false,
            seed: seed,
            ...textureOptions
          });

          ctx.restore();
        }

        if (progress < 1) {
          animationId = requestAnimationFrame(animate);
        } else {
          animationId = null;
        }
      }

      animationId = requestAnimationFrame(animate);
    }

    // 슬라이더 업데이트
    document.getElementById('animDuration').addEventListener('input', function() {
      document.getElementById('animDurationValue').textContent = this.value + 'ms';
    });
    document.getElementById('animLayers').addEventListener('input', function() {
      document.getElementById('animLayersValue').textContent = this.value;
    });

    // ==========================================
    // 테스트 5: 영역 마스킹
    // ==========================================

    function redrawRegion() {
      const canvas = document.getElementById('regionCanvas');
      const ctx = canvas.getContext('2d');

      const regionXInput = document.getElementById('regionX').value;
      const regionYInput = document.getElementById('regionY').value;
      const transparentMode = document.getElementById('regionTransparent').checked;

      const [xStart, xEnd] = regionXInput.split('-').map(s => parseInt(s.trim()));
      const [yStart, yEnd] = regionYInput.split('-').map(s => parseFloat(s.trim()));

      // 배경 클리어
      ctx.fillStyle = '#0f0f23';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 샘플 데이터
      const data = [0.12, 0.24, 0.28, 0.20, 0.16];
      const padding = 60;
      const chartWidth = canvas.width - padding * 2;
      const chartHeight = canvas.height - padding * 2;
      const barWidth = chartWidth / data.length * 0.8;
      const gap = chartWidth / data.length * 0.2;
      const maxY = 0.3;

      // 축 그리기
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, canvas.height - padding);
      ctx.lineTo(canvas.width - padding, canvas.height - padding);
      ctx.stroke();

      // Y축 라벨
      ctx.fillStyle = '#e5e7eb';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'right';
      for (let i = 0; i <= 5; i++) {
        const y = canvas.height - padding - (chartHeight * i / 5);
        const value = (maxY * i / 5).toFixed(2);
        ctx.fillText(value, padding - 10, y + 4);
      }

      // 막대 그리기
      data.forEach((value, index) => {
        const x = padding + (barWidth + gap) * index + gap / 2;
        const barHeight = (value / maxY) * chartHeight;
        const y = canvas.height - padding - barHeight;

        const gradient = ctx.createLinearGradient(x, y, x, canvas.height - padding);
        gradient.addColorStop(0, '#AEFF7E');
        gradient.addColorStop(1, '#68994C');

        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, barWidth, barHeight);

        ctx.strokeStyle = '#68994C';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, barWidth, barHeight);
      });

      // 영역 마스킹
      if (!isNaN(xStart) && !isNaN(xEnd) && !isNaN(yStart) && !isNaN(yEnd)) {
        const regionLeft = padding + (barWidth + gap) * xStart;
        const regionRight = padding + (barWidth + gap) * xEnd + barWidth + gap;
        const regionTop = canvas.height - padding - (yEnd / maxY) * chartHeight;
        const regionBottom = canvas.height - padding - (yStart / maxY) * chartHeight;

        renderTearMask(ctx, {
          x: regionLeft - 5,
          y: regionTop - 5,
          width: regionRight - regionLeft + 10,
          height: regionBottom - regionTop + 10
        }, {
          edgeComplexity: 0.8,
          tearColor: '#1a1a2e',
          shadowEnabled: true,
          transparent: transparentMode,
          seed: 77
        });
      }
    }

    // 초기 렌더링
    window.onload = function() {
      redrawTearPath();
      redrawChart();
      redrawTable();
      // 애니메이션 초기 상태
      drawAnimBase(
        document.getElementById('animCanvas').getContext('2d'),
        document.getElementById('animCanvas')
      );
      redrawRegion();
    };

    // 슬라이더 실시간 업데이트
    document.getElementById('complexity').addEventListener('input', redrawTearPath);
    document.getElementById('seed').addEventListener('input', redrawTearPath);
    document.getElementById('pathLayers').addEventListener('input', redrawTearPath);
    document.getElementById('pathFiber').addEventListener('change', redrawTearPath);
    document.getElementById('pathEdgeColor').addEventListener('change', redrawTearPath);
    document.getElementById('pathTransparent').addEventListener('change', redrawTearPath);
  </script>
</body>
</html>
